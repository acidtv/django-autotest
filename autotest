#!/usr/bin/env python3

# Django auto test runner
#
# Watches for changed python files and then automatically
# runs the tests for the app the file is in.
# If the changed file is a test, only those tests will run.
# Run it in the root of your Django repo.
#
# Usage:
# $ autotest
#
# Requirements:
# - watchfiles

import argparse
import ast
import asyncio
import os
import re
import subprocess
from collections import defaultdict
from pathlib import Path

import watchfiles

CURRENT_DIR = Path(os.getcwd())


class TestCase(str): ...


class TestPattern(str): ...


class TestCaseNotFoundException(Exception): ...


def foo():
    # After test_*.py file was saved:
    # - run git diff -U0
    # - get changed lines per file
    # - save changed lines per file
    # - check if changed lines differ since last time
    # - create map of func/lineno-range from testfile
    # - check which testmethods belong to changed lines
    # - run the relevant tests
    ...


Diff = dict[int, str]
FileDiffs = dict[Path, Diff]


def get_diffs() -> FileDiffs:
    result = subprocess.run(
        ["git", "diff", "--unified=0", "--color=never"],
        stdout=subprocess.PIPE,
        stderr=subprocess.PIPE,
    )
    file_diffs: FileDiffs = defaultdict(dict)
    for line in result.stdout.splitlines():
        line = line.decode()
        if line.startswith("+++") or line.startswith("---"):
            match = re.match(r"\+\+\+ b/(.*)", line)
            if match:
                file = Path(match[1])
        elif line.startswith("@@"):
            match = re.match(r"@@ -\d+(,\d+)* \+(\d+)(,\d+)* @@.*", line)
            if not match:
                raise Exception("Could not parse diff line indicator")
            lineno = int(match[2])
        elif line.startswith("+") or line.startswith("-"):
            # TODO: do not count '-' lines as line numbers?
            file_diffs[file][lineno] = line
            lineno += 1
    return file_diffs


def compare_file_diffs(old: Diff, new: Diff) -> list[int]:
    """Compare diffs and returned changed lines between them."""
    changed: list[int] = []
    for lineno, line in new.items():
        if lineno not in old:
            changed.append(lineno)
        elif line != old[lineno]:
            changed.append(lineno)
    return changed


def create_function_map_from_file(file: Path) -> dict[range, str]:
    nodes = ast.parse(file.read_text())
    map = {}
    for node in ast.walk(nodes):
        if isinstance(node, ast.FunctionDef):
            map[range(node.lineno, node.end_lineno)] = node.name
    return map


def get_changed_functions(file: Path):
    previous_diff = {}
    current_diffs = get_diffs()
    current_diff = current_diffs[file]
    changed_lines = compare_file_diffs(previous_diff, current_diff)
    changed_functions = []
    function_map = create_function_map_from_file(file)
    for lineno in changed_lines:
        for linerange, function in function_map:
            if lineno in linerange:
                changed_functions.append(function)
    return changed_functions


def path_to_module(path: Path) -> str:
    relative_path = path.relative_to(CURRENT_DIR).with_suffix("")
    module = str(relative_path).replace("/", ".")
    return module


def module_to_testcase(module: str) -> TestCase:
    # Return complete module string if this is a test
    file = module.rsplit(".", maxsplit=1)[-1]
    if file.startswith("test_"):
        return TestCase(module)

    # Otherwise return the app the file is in
    app = ".".join(module.split(".")[0:2])
    return TestCase(app)


FailedTests = list[tuple[str, str]]


async def run_test(
    testcases: list[TestCase] | None = None, patterns: list[TestPattern] | None = None
) -> FailedTests:
    if testcases:
        cmd = f"./manage.py test {' '.join(testcases)}"
        info = ", ".join(testcases)
    elif patterns:
        command_patterns = [f" -k {pattern}" for pattern in patterns]
        cmd = f"./manage.py test {' '.join(command_patterns)}"
        info = f"patterns: {', '.join(patterns)}"
    else:
        raise Exception("Either `testcase` or `patterns` is required")

    print("")
    print("########################################################")
    print("Testing", info)
    print("########################################################")

    # Set stdout and stderr to None so output is redirected
    # to the parent process' stdout and stderr.
    # proc = await asyncio.create_subprocess_shell(cmd, stdout=None, stderr=None)
    proc = await asyncio.create_subprocess_shell(
        cmd, stdout=asyncio.subprocess.PIPE, stderr=asyncio.subprocess.PIPE
    )

    async def stdout_reader(stdout):
        while True:
            output = await stdout.read(10)
            print(output.decode(), end="")
            if not output:
                break

    async def stderr_reader(stderr) -> tuple[FailedTests, list[str]]:
        fail_regex = r"^(?P<mode>(ERROR|FAIL)): (?P<name>.+) \((?P<test>.+)\).*$"
        failed = []
        disappeared: list[str] = []
        while True:
            output = await stderr.readline()
            output = output.decode()
            match = re.match(fail_regex, output)

            if match:
                if "unittest.loader._FailedTest" in output:
                    disappeared.append(match.group("name"))
                else:
                    failed.append((match.group("mode"), match.group("test")))

            print(output, end="")
            if not output:
                break
        return failed, disappeared

    _, (failed_tests, disappeared_tests) = await asyncio.gather(
        stdout_reader(proc.stdout), stderr_reader(proc.stderr)
    )
    exit_code = await proc.wait()

    print("")
    if failed_tests or disappeared_tests or exit_code != 0:
        print(f"# ðŸ”´ {len(failed_tests)} Tests failed!")
        for mode, failed_test in failed_tests:
            print(f"# - {mode}: {failed_test}")
        for disappeared_test in disappeared_tests:
            print(f"# - DISAPPEARED: {disappeared_test}")
    else:
        print("# âœ… Tests passed.")

    return failed_tests


async def testrunner(queue: asyncio.Queue):
    """Worker that watches the queue for tests to run"""
    failed_tests = []

    def test_labels(failed_tests: FailedTests) -> list[str]:
        return [label for mode, label in failed_tests]

    while True:
        match testcase := await queue.get():
            case TestCase():
                if failed_tests:
                    testcases = test_labels(failed_tests)
                else:
                    testcases = [testcase]
                failed_tests = await run_test(testcases=testcases)
            case TestPattern():
                failed_tests = await run_test(patterns=[testcase])
            case _:
                raise Exception("Unknown testcase type")

        print(f"# {queue.qsize()} testcase(s) in queue.")


async def main(pattern: str | None = None):
    queue = asyncio.Queue()
    task = asyncio.create_task(testrunner(queue))

    print("Watching for changes to python files...")
    if pattern:
        print(f"Pattern: {pattern}")
    print("")

    try:
        async for changes in watchfiles.awatch("."):
            testcases: set[TestCase] = set()
            for change, file_path in changes:
                if not file_path.endswith(".py"):
                    continue
                print(get_changed_functions(Path(file_path)))
                module = path_to_module(Path(file_path))
                testcase = module_to_testcase(module)
                if testcase:
                    testcases.add(testcase)

            # If pattern is defined always run tests matching the pattern
            if pattern:
                queue.put_nowait(TestPattern(pattern))
            else:
                for testcase in testcases:
                    if not (testcase in queue._queue):
                        queue.put_nowait(testcase)
    finally:
        task.cancel()


if __name__ == "__main__":
    parser = argparse.ArgumentParser(
        prog="autotest", description="Automatically run Django tests when files change."
    )
    parser.add_argument(
        "-k",
        type=str,
        dest="pattern",
        help="Only run test methods and classes that match the pattern. Passed to Django.",
    )
    args = parser.parse_args()

    try:
        asyncio.run(main(pattern=args.pattern))
    except KeyboardInterrupt:
        print("")
        print("Stopped!")
